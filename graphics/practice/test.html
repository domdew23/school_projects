<html>
	<head>
		<title>Triangle 2</title>
	</head>
	<body>
		<canvas width="800" height="800" id="main_canvas"></canvas>
		<script>
			var gl;
			var canvas;
			var program;
			var num_items = 0;

			function main(){
				config();
				program = create_program();
				var count = 1;

				var pos = (1/3);
				var neg = pos * -1;
				// Copy an array of data points forming triangle to GPU
				var vertices = [
					//X  Y	
					neg,neg,
					neg,pos,
					pos,pos,
					pos,neg
				];

				get_verts(vertices, count);
				console.log(vertices.length);
				/*	if (i % 2 == 0){
						//X
						vertices.push(x);
						console.log("Vertex: " + i + "\nX: " + x);
					} else {
						//Y
						tmp = x + (Math.abs(2 * y) + Math.abs(vertices[i])); 
						vertices.push(tmp);
						console.log("Y: " + tmp);
					}
				}*/

				var buffer = gl.createBuffer(); // set aside memory on GPU for data
				gl.bindBuffer(gl.ARRAY_BUFFER, buffer); // select this buffer as something to manipulate
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW); //copy triangle data to buffer
				//var v1_size = vertices.length * Float32Array.BYTES_PER_ELEMENT;

				var coordinatesVar = gl.getAttribLocation(program, "coordinates");
				gl.vertexAttribPointer(
					coordinatesVar, 
					2, 
					gl.FLOAT, 
					false, 
					0, //2 * Float32Array.BYTES_PER_ELEMENT, 
					0);

				gl.enableVertexAttribArray(coordinatesVar);
				render();
			}


		function get_verts(vertices, count){
			console.log("count: " + count);
			if (count == 0){
				return vertices;
			}
			count--;
			var length = vertices.length;
			var children = [];
			var child = [];

			for (i = 0; i < 8; i++){
				var next = [];
				var vert_to_add;
				for (j = 0; j < length; j++){
					console.log("length: " + length + " j: " + j);
					vert = vertices[j] / 3;
					if (i < 3){
						vert_to_add = vert - (3 * Math.abs(2 * vert));
					} else if (i < 7 && i != 3){
						vert_to_add = vert + (3 * Math.abs(2 * vert));
					} else {
						vert_to_add = vert;
					}

					switch (i){
						case 0:
							// bottom_left
							vertices.push(vert_to_add);
							break;
						case 1:
							// side left
							if (j % 2 == 0){
								// X
								vertices.push(vert_to_add)
							} else {
								// Y
								tmp = vert_to_add + (3 * (Math.abs(2 * vert))); 	
								vertices.push(tmp);
							}
							break;
						case 2:
							// top left
							if (j % 2 == 0){
								// X
								vertices.push(vert_to_add)
							} else {
								// Y
								tmp = vert_to_add + (6 * (Math.abs(2 * vert))); 	
								vertices.push(tmp);
							}
							break;
						case 3:
							// top middle
							if (j % 2 == 0){
								vertices.push(vert_to_add)
							} else {
								tmp = vert_to_add + (3 * (Math.abs(2 * vert)));
								vertices.push(tmp); 	
							}
							break;
						case 4:
							//top_right
							vertices.push(vert_to_add);
							break;
						case 5:
							// side right
							if (j % 2 == 0){
								// X
								vertices.push(vert_to_add)
							} else {
								// Y
								tmp = vert_to_add - (3 * (Math.abs(2 * vert))); 	
								vertices.push(tmp);
							}
							break;
						case 6:
							// bottom right
							if (j % 2 == 0){
								// X
								vertices.push(vert_to_add)
							} else {
								// Y
								tmp = vert_to_add - (6 * (Math.abs(2 * vert))); 	
								vertices.push(tmp);
							}
							break;
						case 7:
							//bottom middle
							if (j % 2 == 0){
								vertices.push(vert_to_add)
							} else {
								tmp = vert_to_add - (3 * (Math.abs(2 * vert))); 
								vertices.push(tmp);	
							}
							break;
						default:
							console.log("something went wrong");
					}
				}	
			}

			console.log("length: " + vertices.length)
			num_items++;
			get_verts(vertices, count);
			num_items = vertices.length / 8;
		}

		function render(){
			gl.clear(gl.COLOR_BUFFER_BIT);
			var offset = 0;
			for (i = 0; i < num_items; i++){
				gl.drawArrays(gl.TRIANGLE_FAN, offset, 4);
				offset += 4;
			}
		}
			
		function config(){
			// Configure the canvas to use WebGl
			canvas = document.getElementById('main_canvas');
			try {
				gl = canvas.getContext('webgl');
			} catch (e){
				try {
					gl = canvas.getContext('experimental-webgl');
				} catch (ex){
					throw new Error('no WebGL found');
				}
			}		
		}

		function create_program(){
			// Create simple vertex shader
			var vertCode = 
				'attribute vec4 coordinates;' + 
				'void main() {' +
				' gl_Position = coordinates;' +
				'}';

			var vertShader = gl.createShader(gl.VERTEX_SHADER);
			gl.shaderSource(vertShader, vertCode);
			gl.compileShader(vertShader);
			
			// check if everything compiled correctly
			if (!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)){
				throw new Error(gl.getShaderInfoLog(vertShader));
			}

			// Create simple fragment shader (R, G, B, alpha)
			var fragCode = 
				'precision mediump float;' +
				'void main() {' +
				'   gl_FragColor = vec4(0.1, 0.6, 0.9, 1.0);' +
				'}';
			
			var fragShader = gl.createShader(gl.FRAGMENT_SHADER);
			gl.shaderSource(fragShader, fragCode);
			gl.compileShader(fragShader);
			// check if everything compiled correctly
			if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)){
				throw new Error(gl.getShaderInfoLog(fragShader));
			}

			// Put vertex and fragment shaders together into complete program
			var program = gl.createProgram();
			gl.attachShader(program, vertShader);
			gl.attachShader(program, fragShader);
			gl.linkProgram(program);
			// make sure program was created correctly
			if (!gl.getProgramParameter(program, gl.LINK_STATUS)){
				throw new Error(gl.getProgramInfoLog(program));
			}

			gl.viewport(0, 0, canvas.width, canvas.height);
			gl.clearColor(0.0, 0.0, 0.0, 1.0);
			gl.useProgram(program);
			return program;
		}

		window.onload = main;
		</script>
	</body>
</html>		







