<html>
	<head>
		<title>Triangle 2</title>
	</head>
	<body>
		<canvas width="800" height="800" id="main_canvas"></canvas>
		<script>
			var gl;
			var canvas;
			var program;
			var num_items = 1;

			function main(){
				config();
				program = create_program();
				var count = 1;

				var pos = (1/3);
				var neg = pos * -1;
				// Copy an array of data points forming triangle to GPU
				var vertices = [
					//X  Y	
					neg,neg,
					neg,pos,
					pos,pos,
					pos,neg
				];

				get_verts(vertices, count);
				console.log(vertices.length);
				/*	if (i % 2 == 0){
						//X
						vertices.push(x);
						console.log("Vertex: " + i + "\nX: " + x);
					} else {
						//Y
						tmp = x + (Math.abs(2 * y) + Math.abs(vertices[i])); 
						vertices.push(tmp);
						console.log("Y: " + tmp);
					}
				}*/

				var buffer = gl.createBuffer(); // set aside memory on GPU for data
				gl.bindBuffer(gl.ARRAY_BUFFER, buffer); // select this buffer as something to manipulate
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW); //copy triangle data to buffer
				//var v1_size = vertices.length * Float32Array.BYTES_PER_ELEMENT;

				var coordinatesVar = gl.getAttribLocation(program, "coordinates");
				gl.vertexAttribPointer(
					coordinatesVar, 
					2, 
					gl.FLOAT, 
					false, 
					0, //2 * Float32Array.BYTES_PER_ELEMENT, 
					0);

				gl.enableVertexAttribArray(coordinatesVar);
				render();
			}


		function get_verts(vertices, count){
			console.log("count: " + count);
			if (count == 0){
				return vertices;
			}
			count--;
			var length = vertices.length;

			for (i = 0; i < 8; i++){
				for (j = 0; j < length; j++){
					y = vertices[j] / 3;
					switch (i){
						case 0:
							x = y - (2/3);
							vertices.push(x);
							break;
						case 1:
							console.log("At i = 1");
							break;
						case 2:
							break;
						case 3:
							break;
						case 4:
							break;
						case 5:
							break;
						case 6:
							break;
						case 7:
							break;
						default:
							console.log("something went wrong");
					}
				}	
			}

			console.log("length: " + vertices.length)
			num_items++;
			get_verts(vertices, count);
		}

		function render(){
			gl.clear(gl.COLOR_BUFFER_BIT);
			var offset = 0;
			for (i = 0; i < num_items; i++){
				gl.drawArrays(gl.TRIANGLE_FAN, offset, 4);
				offset += 4;
			}
		}
			
		function config(){
			// Configure the canvas to use WebGl
			canvas = document.getElementById('main_canvas');
			try {
				gl = canvas.getContext('webgl');
			} catch (e){
				try {
					gl = canvas.getContext('experimental-webgl');
				} catch (ex){
					throw new Error('no WebGL found');
				}
			}		
		}

		function create_program(){
			// Create simple vertex shader
			var vertCode = 
				'attribute vec4 coordinates;' + 
				'void main() {' +
				' gl_Position = coordinates;' +
				'}';

			var vertShader = gl.createShader(gl.VERTEX_SHADER);
			gl.shaderSource(vertShader, vertCode);
			gl.compileShader(vertShader);
			
			// check if everything compiled correctly
			if (!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)){
				throw new Error(gl.getShaderInfoLog(vertShader));
			}

			// Create simple fragment shader (R, G, B, alpha)
			var fragCode = 
				'precision mediump float;' +
				'void main() {' +
				'   gl_FragColor = vec4(0.1, 0.6, 0.9, 1.0);' +
				'}';
			
			var fragShader = gl.createShader(gl.FRAGMENT_SHADER);
			gl.shaderSource(fragShader, fragCode);
			gl.compileShader(fragShader);
			// check if everything compiled correctly
			if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)){
				throw new Error(gl.getShaderInfoLog(fragShader));
			}

			// Put vertex and fragment shaders together into complete program
			var program = gl.createProgram();
			gl.attachShader(program, vertShader);
			gl.attachShader(program, fragShader);
			gl.linkProgram(program);
			// make sure program was created correctly
			if (!gl.getProgramParameter(program, gl.LINK_STATUS)){
				throw new Error(gl.getProgramInfoLog(program));
			}

			gl.viewport(0, 0, canvas.width, canvas.height);
			gl.clearColor(0.0, 0.0, 0.0, 1.0);
			gl.useProgram(program);
			return program;
		}

		window.onload = main;
		</script>
	</body>
</html>		







